package array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class MajorityNumber3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] a = new int[]{163,96,134,174,69,269,185,41,98,121,10,149,84,311,98,250,162,197,178,94,180,98,96,152,98,222,37,98,175,106,322,98,325,195,294,213,198,105,98,172,309,98,157,204,108,167,98,301,98,162,147,165,98,154,71,335,248,180,265,158,13,211,22,85,254,22,81,110,98,328,52,210,342,49,194,114,333,342,206,166,66,248,83,167,69,98,274,138,63,98,342,178,310,175,126,73,292,282,178,277,291,274,172,40,107,53,98,308,108,209,311,139,255,50,259,10,282,273,32,236,232,98,133,100,60,112,26,341,217,98,141,85,165,286,155,308,115,193,81,330,310,91,47,251,98,76,29,259,10,58,24,128,70,76,56,255,154,276,71,251,105,114,278,238,73,327,63,246,331,336,132,263,71,112,98,204,13,267,283,162,330,138,266,130,314,154,293,198,163,126,84,210,140,117,327,98,130,192,143,173,344,234,234,98,98,41,281,263,199,156,271,338,263,28,340,212,98,269,123,292,71,265,278,266,161,286,299,247,73,10,114,167,131,214,153,340,323,11,98,104,98,198,22,126,76,216,148,238,243,285,98,32,124,161,54,262,190,83,234,98,172,125,33,302,283,297,91,183,102,310,31,147,86,309,78,98,322,216,19,214,88,272,100,102,21,295,31,228,205,233,300,238,86,271,113,255,305,30,21,118,252,51,266,128,284,128,209,98,342,98,235,200,223,327,126,93,97,263,97,98,157,277,98,30,295,210,179,73,106,269,242,241,82,47,57,108,229,98,94,128,143,298,154,240,224};
		System.out.println(new MajorityNumber3().majorityNumber(utils.PrintUtils.toList(a), 11));
	}
    /**
     * @param nums: A list of integers
     * @param k: As described
     * @return: The majority number
     * 给定一个整型数组，找到主元素，它在数组中的出现次数严格大于数组元素个数的1/k。
     * 要求时间复杂度为O(n)，空间复杂度为O(k)
     */
    public int majorityNumber(ArrayList<Integer> nums, int k) {
        // write your code
    	int size = nums.size();
    	int cnt = size / k;
    	HashMap<Integer, Integer> map = new HashMap<>();
    	for (int i = 0; i < size; i++) {
    		int cur = nums.get(i);
    		if (map.containsKey(cur)) {
    			int value = map.get(cur);
    			if (value > cnt) {
    				return cur;
    			}
    			map.put(cur, value + 1);
    		} else {
    			map.put(cur, 1);
    		}
    	}
    	
    	for (int i = 0; i < size; i++) {
    		int key = nums.get(i);
    		int value = map.get(key);
    		if (value > cnt) {
    			return key;
    		}
    	}
    	return 0;
    }
}
